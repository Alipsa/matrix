plugins {
  id "com.github.ben-manes.versions" version "0.54.2-SNAPSHOT" apply false
  //id "com.github.ben-manes.versions" version "0.53.0" apply false
}

description = "Groovy libraries for working with matrix ([][] data)"

subprojects {
  apply plugin: "com.github.ben-manes.versions"
}

def isNonStable = { String v ->
  def stableKeyword = ['RELEASE','FINAL','GA'].any { v?.toUpperCase()?.contains(it) }
  def regex = /^[0-9,.v-]+(-r)?$/
  !stableKeyword && !(v ==~ regex)
}

// Extract leading numeric major: "5.0.0", "v5.0.0", "5.0.0-RC1"
def majorOf = { String v ->
  def m = (v ?: "") =~ /(?i)^\D*?(\d+)/
  m.find() ? (m.group(1) as int) : -1
}

allprojects {
  plugins.withType(MavenPublishPlugin).configureEach {
    project.afterEvaluate {project ->
      def projectName = project.name
      def projectGroup = project.group.toString()
      def projectVersion = project.version.toString()
      def publicationCoordinates = "${projectGroup}:${projectName}:${projectVersion}"
      def publishMessage = "ðŸš€ Published ${projectName}: ${publicationCoordinates}"
      tasks.withType(PublishToMavenLocal).configureEach {
        doLast {
          println publishMessage
          if (projectVersion.contains('-SNAPSHOT')) {
            println "- Clearing Grapes cache for ${projectGroup}:${projectName} as it is a SNAPSHOT..."
            try {
              def userHome = System.getProperty("user.home")
              // Grapes default layout: ~/.groovy/grapes/<group>/<module>
              def grapeDir = new File(userHome, ".groovy/grapes/${projectGroup}/${projectName}")

              if (grapeDir.exists()) {
                // recursively delete directory
                if (grapeDir.deleteDir()) {
                  println "  ðŸ‡ Cleared Grapes cache for ${projectGroup}:${projectName}"
                } else {
                  println "  âš ï¸ Found Grapes cache at ${grapeDir} but failed to delete it."
                }
              } else {
                println "  ðŸ‡ ${projectGroup}:${projectName} is not cached in Grapes."
              }
            } catch (Exception e) {
              println "  âš ï¸ Error clearing Grapes cache: ${e.message}"
            }
          }
        }
      }
    }
  }
  tasks.matching { it.name == "dependencyUpdates" }.configureEach {
    // Plugin is not compatible with configuration cache (uses Task.project at execution time).
    // This invalidates the cache entry when dependencyUpdates is in the task graph.
    // Also run with --no-parallel on Gradle 9.x: ./gradlew dependencyUpdates --no-parallel
    //notCompatibleWithConfigurationCache("dependencyUpdates plugin uses Task.project at execution time")

    gradleReleaseChannel = "current"
    checkForGradleUpdate = false // optional: silence Gradle RC noise
    def projectName = project.name
    def markerFile = rootProject.layout.buildDirectory
        .file("dependencyUpdates/.hasOutdated").get().asFile

    outputFormatter = { result ->
      def outdated = result.outdated.dependencies
      if (outdated) {
        markerFile.parentFile.mkdirs()
        markerFile.text = 'true'
        println "${projectName}:"
        outdated.each { dep ->
          def latest = dep.available.release ?: dep.available.milestone ?: dep.available.integration
          println "  ${dep.group}:${dep.name} ${dep.version} -> ${latest}"
        }
      }
    }

    resolutionStrategy {
      componentSelection {
        all { s ->
          if (isNonStable(s.candidate.version) && !isNonStable(s.currentVersion)) {
            s.reject('Release candidate')
          }
          if (s.candidate.group == 'com.github.haifengl' && majorOf(s.candidate.version) >= 5) {
            s.reject('Blocked: Smile >= 5 (needs Java 25)')
          }
          if (s.candidate.group == 'org.openjfx' && majorOf(s.candidate.version) >= 24) {
            s.reject('Blocked: JavaFx >= 24 (Exceeds max version for Java 21)')
          }
        }
      }
    }
  }
}

// Summary task that runs after all dependencyUpdates tasks complete
tasks.register('dependencyUpdatesSummary') {
  description = 'Prints a summary after all dependency update checks'
  def markerFile = rootProject.layout.buildDirectory
      .file("dependencyUpdates/.hasOutdated").get().asFile
  dependsOn allprojects.collect { p ->
    p.tasks.matching { it.name == 'dependencyUpdates' }
  }
  doLast {
    if (!markerFile.exists()) {
      println 'All dependencies are up-to-date.'
    }
    markerFile.delete()
  }
}

// Wire: running dependencyUpdates on root also triggers the summary
tasks.matching { it.name == 'dependencyUpdates' }.configureEach {
  finalizedBy tasks.named('dependencyUpdatesSummary')
}
