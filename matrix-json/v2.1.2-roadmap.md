# Matrix-JSON Module v2.1.2 Roadmap

**Module**: `matrix-json`
**Current Version**: 2.1.2-SNAPSHOT
**Date**: 2026-01-22
**Status**: Enhancement & Test Coverage Expansion

---

## Executive Summary

The matrix-json module is in **excellent condition** with solid architecture, comprehensive error handling, and good test coverage. This roadmap focuses on:

1. **API Consistency** - Aligning with matrix-csv module patterns
2. **Test Coverage Expansion** - Adding edge case tests (8 ‚Üí 15+ tests)
3. **Convenience Enhancements** - Adding helper methods for common use cases
4. **Documentation Polish** - Minor improvements to GroovyDoc

**Overall Assessment**: üü¢ **Healthy** (No critical bugs, optional enhancements only)

---

## Current State Analysis

### Strengths ‚úÖ

1. **Streaming Architecture** - Uses Jackson streaming API for O(1) memory regardless of JSON size
2. **Clean Error Handling** - Comprehensive duplicate key detection with descriptive messages
3. **Nested Structure Support** - Automatic flattening of nested objects/arrays to dot-notation
4. **Test Coverage** - 8 tests with 100% pass rate
5. **Well-Documented** - All public methods have GroovyDoc
6. **No Code Duplication** - Clean separation of concerns

### Areas for Enhancement üü°

1. **API Consistency** - Missing URL/Path support that CSV module has
2. **Test Gaps** - Edge cases like empty arrays, single rows, error scenarios not explicitly tested
3. **Static Export Methods** - JsonExporter is instance-only (CSV has both patterns)
4. **Convenience Methods** - Missing String file path support (like CSV added in Phase 4)

---

## Phase 0: Critical Bug Fixes üî¥

**Priority**: CRITICAL
**Estimated Impact**: None needed - no bugs found

‚úÖ **No critical bugs identified**

The code quality is excellent with proper error handling and resource management.

---

## Phase 1: API Consistency Enhancements üü¢

**Priority**: MEDIUM
**Estimated Impact**: Improved developer experience, consistency with matrix-csv

### 1.1 Add URL Support to JsonImporter

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonImporter.groovy`

**Issue**: CSV module supports importing from URLs, but JSON module doesn't

**Add Methods**:
```groovy
/**
 * Parse JSON from a URL into a Matrix.
 *
 * @param url URL pointing to JSON content
 * @param charset character encoding (default UTF-8)
 * @return a Matrix with columns derived from JSON keys
 * @throws IOException if reading the URL fails
 */
static Matrix parse(URL url, Charset charset = StandardCharsets.UTF_8) {
  url.openStream().withCloseable { InputStream is ->
    return parse(is, charset)
  }
}

/**
 * Parse JSON from a URL string into a Matrix.
 *
 * @param urlString String URL pointing to JSON content
 * @param charset character encoding (default UTF-8)
 * @return a Matrix with columns derived from JSON keys
 * @throws IOException if reading the URL fails or URL is invalid
 */
static Matrix parse(String urlString, Charset charset = StandardCharsets.UTF_8) {
  return parse(new URI(urlString).toURL(), charset)
}
```

**Note**: This will conflict with existing `parse(String str)` method which parses JSON content.
**Solution**: Rename the String URL method to `parseFromUrl(String urlString)` to avoid ambiguity.

### 1.2 Add Path Support to JsonImporter

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonImporter.groovy`

**Issue**: CSV module supports `Path` API, JSON module doesn't

**Add Method**:
```groovy
/**
 * Parse JSON from a Path into a Matrix.
 *
 * @param path Path to the file containing JSON array
 * @param charset character encoding (default UTF-8)
 * @return a Matrix with columns derived from JSON keys
 * @throws IOException if reading the file fails
 */
static Matrix parse(Path path, Charset charset = StandardCharsets.UTF_8) {
  return parse(path.toFile(), charset)
}
```

**Required Import**: `import java.nio.file.Path`

### 1.3 Add File Path Convenience Method

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonImporter.groovy`

**Issue**: Users have to create File objects manually for file paths

**Add Method**:
```groovy
/**
 * Parse JSON from a file path string (convenience method).
 *
 * <p>This method provides a convenient way to import JSON using a String file path
 * instead of creating a File object. It uses default UTF-8 encoding.</p>
 *
 * @param filePath path to the JSON file as a String
 * @return Matrix containing the parsed data
 * @throws IOException if reading the file fails or file not found
 */
static Matrix parseFromFile(String filePath, Charset charset = StandardCharsets.UTF_8) {
  return parse(new File(filePath), charset)
}
```

**Rationale**: Matches the `importCsvFromFile()` convenience method added to matrix-csv in Phase 4

---

## Phase 2: Test Coverage Expansion üìö

**Priority**: HIGH
**Estimated Impact**: Improved reliability, edge case coverage (8 ‚Üí 15+ tests target)

### 2.1 JsonImporter Edge Case Tests

**File**: `src/test/groovy/JsonImporterTest.groovy`

**Add Tests**:

```groovy
// Empty JSON array
@Test
void testEmptyJsonArray() {
  Matrix m = JsonImporter.parse('[]')
  assertNotNull(m, "Matrix should not be null")
  assertEquals(0, m.rowCount(), "Empty JSON should have 0 rows")
  assertEquals(0, m.columnCount(), "Empty JSON should have 0 columns")
}

// Single row JSON
@Test
void testSingleRow() {
  Matrix m = JsonImporter.parse('[{"id": 1, "name": "Alice"}]')
  assertEquals(1, m.rowCount(), "Should have 1 row")
  assertEquals(2, m.columnCount(), "Should have 2 columns")
  assertEquals(['id', 'name'], m.columnNames())
}

// Sparse data (null values)
@Test
void testSparseData() {
  Matrix m = JsonImporter.parse('''[
    {"a": 1, "b": 2},
    {"a": 3},
    {"b": 4, "c": 5}
  ]''')
  assertEquals(3, m.rowCount(), "Should have 3 rows")
  assertEquals(3, m.columnCount(), "Should have 3 columns")
  assertEquals(['a', 'b', 'c'], m.columnNames())
  // Row 0: [1, 2, null]
  // Row 1: [3, null, null]
  // Row 2: [null, 4, 5]
  assertNull(m[0, 'c'], "Row 0 column c should be null")
  assertNull(m[1, 'b'], "Row 1 column b should be null")
  assertNull(m[2, 'a'], "Row 2 column a should be null")
}

// Invalid JSON error handling
@Test
void testInvalidJson() {
  IllegalArgumentException ex = assertThrows(IllegalArgumentException) {
    JsonImporter.parse('{"not": "an array"}')
  }
  assertTrue(ex.message.contains("Expected JSON array"), "Error should mention array expectation")
}

// Malformed JSON
@Test
void testMalformedJson() {
  assertThrows(Exception) {
    JsonImporter.parse('[{"a": 1,}]')  // Trailing comma
  }
}

// File not found
@Test
void testFileNotFound() {
  assertThrows(FileNotFoundException) {
    JsonImporter.parse(new File("/nonexistent/path.json"))
  }
}
```

### 2.2 JsonExporter Edge Case Tests

**File**: `src/test/groovy/JsonExporterTest.groovy`

**Add Tests**:

```groovy
// Null matrix validation
@Test
void testNullMatrixValidation() {
  NullPointerException ex = assertThrows(NullPointerException) {
    new JsonExporter(null)
  }
}

// Empty matrix export
@Test
void testEmptyMatrixExport() {
  Matrix empty = Matrix.builder().build()
  JsonExporter exporter = new JsonExporter(empty)
  String json = exporter.toJson()
  assertEquals('[]', json, "Empty matrix should export as empty JSON array")
}

// Matrix with columns but no rows
@Test
void testEmptyMatrixWithColumns() {
  Matrix m = Matrix.builder()
    .matrixName('empty')
    .data(id: [], name: [])
    .build()

  JsonExporter exporter = new JsonExporter(m)
  String json = exporter.toJson()
  assertEquals('[]', json, "Matrix with 0 rows should export as empty array")
}

// Pretty print validation
@Test
void testPrettyPrint() {
  Matrix m = Matrix.builder()
    .data(id: [1, 2], name: ['Alice', 'Bob'])
    .build()

  JsonExporter exporter = new JsonExporter(m)
  String json = exporter.toJson(true)

  assertTrue(json.contains('\n'), "Pretty printed JSON should contain newlines")
  assertTrue(json.contains('  '), "Pretty printed JSON should contain indentation")
}
```

---

## Phase 3: JsonExporter Enhancements üîß

**Priority**: LOW
**Estimated Impact**: Improved usability, API consistency

### 3.1 Add Static Export Methods

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonExporter.groovy`

**Issue**: JsonExporter requires instantiation; CSV module has static methods for convenience

**Add Static Methods**:
```groovy
/**
 * Export a Matrix to JSON string (static convenience method).
 *
 * @param table the Matrix to export
 * @param indent whether to pretty print the JSON
 * @return JSON string representation
 */
static String toJson(Matrix table, boolean indent = false) {
  new JsonExporter(table).toJson(indent)
}

/**
 * Export a Matrix to JSON file.
 *
 * @param table the Matrix to export
 * @param outputFile file to write JSON to
 * @param indent whether to pretty print the JSON
 * @throws IOException if writing fails
 */
static void toJsonFile(Matrix table, File outputFile, boolean indent = false) {
  outputFile.text = new JsonExporter(table).toJson(indent)
}
```

**Benefits**:
- One-liner exports: `JsonExporter.toJson(matrix, true)`
- Matches CSV pattern: `CsvExporter.exportToCsv(matrix, file)`

### 3.2 Add Input Validation

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonExporter.groovy`

**Issue**: Constructor doesn't validate null input

**Add to Constructors**:
```groovy
JsonExporter(Matrix table) {
  if (table == null) {
    throw new IllegalArgumentException("Matrix table cannot be null")
  }
  this.table = table
}

JsonExporter(Grid grid, List<String> columnNames) {
  if (grid == null || columnNames == null) {
    throw new IllegalArgumentException("Grid and columnNames cannot be null")
  }
  this.table = Matrix.builder()
    .columnNames(columnNames)
    .data(grid)
    .build()
}
```

### 3.3 Consider Adding @CompileStatic

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonExporter.groovy`

**Issue**: JsonImporter uses `@CompileStatic`, but JsonExporter doesn't

**Analysis**:
- **Pros**: Type safety, consistency with JsonImporter
- **Cons**: Uses closures for column formatters (dynamic feature)
- **Decision**: OPTIONAL - current approach is fine

**If Adding**:
```groovy
@CompileStatic
class JsonExporter {
  // Will require explicit typing for closure parameters
}
```

**Recommendation**: Skip this unless strict typing is required project-wide

---

## Phase 4: Documentation Enhancements üìù

**Priority**: LOW
**Estimated Impact**: Improved developer onboarding

### 4.1 Enhance JsonImporter Class Documentation

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonImporter.groovy`

**Current**:
```groovy
/**
 * Imports JSON arrays into Matrix format using Jackson streaming API.
 * This approach uses constant memory regardless of JSON size by processing
 * one row at a time instead of loading the entire document into memory.
 */
```

**Enhanced**:
```groovy
/**
 * Imports JSON arrays into Matrix format using Jackson streaming API.
 *
 * <p>This class uses constant memory regardless of JSON size by processing
 * one row at a time instead of loading the entire document into memory.</p>
 *
 * <h3>Basic Usage</h3>
 * <pre>
 * // Parse JSON string
 * Matrix m = JsonImporter.parse('[{"id":1,"name":"Alice"},{"id":2,"name":"Bob"}]')
 *
 * // Parse from file
 * Matrix m = JsonImporter.parse(new File("data.json"))
 * </pre>
 *
 * <h3>Nested Structure Handling</h3>
 * <p>Nested objects are automatically flattened to dot-notation keys:</p>
 * <ul>
 *   <li><code>{"a": {"b": 1}}</code> becomes <code>{"a.b": 1}</code></li>
 *   <li><code>{"arr": [1, 2]}</code> becomes <code>{"arr[0]": 1, "arr[1]": 2}</code></li>
 * </ul>
 *
 * <h3>Duplicate Key Detection</h3>
 * <p>Throws {@link IllegalArgumentException} if keys collide after flattening:</p>
 * <pre>
 * // This will throw: "a.b" literal vs "a": {"b": ...} flattened
 * {"a.b": 1, "a": {"b": 2}}
 * </pre>
 *
 * @see JsonExporter
 */
```

### 4.2 Add Examples to flatten() Method

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonImporter.groovy`

**Current**:
```groovy
/**
 * Flatten a nested structure into dot-notation keys.
 * Example: {"a": {"b": 1}} becomes {"a.b": 1}
 * Arrays are indexed: {"arr": [1,2]} becomes {"arr[0]": 1, "arr[1]": 2}
 *
 * @throws IllegalArgumentException if duplicate keys are detected after flattening
 */
```

**Enhanced**:
```groovy
/**
 * Flatten a nested structure into dot-notation keys.
 *
 * <p><b>Examples:</b></p>
 * <ul>
 *   <li>Objects: <code>{"a": {"b": 1}}</code> ‚Üí <code>{"a.b": 1}</code></li>
 *   <li>Arrays: <code>{"arr": [1, 2]}</code> ‚Üí <code>{"arr[0]": 1, "arr[1]": 2}</code></li>
 *   <li>Deep nesting: <code>{"x": {"y": {"z": 3}}}</code> ‚Üí <code>{"x.y.z": 3}</code></li>
 *   <li>Mixed: <code>{"a": [{"b": 1}, {"b": 2}]}</code> ‚Üí <code>{"a[0].b": 1, "a[1].b": 2}</code></li>
 * </ul>
 *
 * <p><b>Collision Detection:</b></p>
 * <p>Throws {@link IllegalArgumentException} if a literal key collides with a flattened path:</p>
 * <pre>
 * // Error: Both flatten to "a.b"
 * {"a.b": 1, "a": {"b": 2}}
 * </pre>
 *
 * @param prefix the current path prefix (empty string at root level)
 * @param node the current node to flatten (Map, List, or leaf value)
 * @param result output map collecting flattened key-value pairs
 * @throws IllegalArgumentException if duplicate keys are detected after flattening
 */
```

### 4.3 Enhance JsonExporter Documentation

**File**: `src/main/groovy/se/alipsa/matrix/json/JsonExporter.groovy`

**Add Class-Level GroovyDoc**:
```groovy
/**
 * Exports Matrix data to JSON format with optional column formatters.
 *
 * <p>Supports custom formatting for individual columns via closures and
 * automatic temporal data formatting with configurable date patterns.</p>
 *
 * <h3>Basic Usage</h3>
 * <pre>
 * Matrix m = Matrix.builder()
 *   .data(id: [1, 2], name: ['Alice', 'Bob'])
 *   .build()
 *
 * JsonExporter exporter = new JsonExporter(m)
 * String json = exporter.toJson()
 * // Output: [{"id":1,"name":"Alice"},{"id":2,"name":"Bob"}]
 *
 * String pretty = exporter.toJson(true)
 * // Output: Pretty-printed with indentation
 * </pre>
 *
 * <h3>Custom Column Formatting</h3>
 * <pre>
 * String json = exporter.toJson([
 *   'salary': {it * 10 + ' kr'},
 *   'date': {DateTimeFormatter.ofPattern('MM/dd/yy').format(it)}
 * ])
 * </pre>
 *
 * <h3>Date Formatting</h3>
 * <pre>
 * // All temporal columns formatted with custom pattern
 * String json = exporter.toJson('MM/dd/yyyy')
 * </pre>
 *
 * @see JsonImporter
 */
class JsonExporter {
```

---

## Implementation Checklist

### Phase 0: Critical Bug Fixes ‚úÖ
- [x] No bugs found - module is healthy

### Phase 1: API Consistency Enhancements ‚úÖ
- [x] 1.1 Add `parse(URL url, Charset charset)` method
- [x] 1.2 Add `parseFromUrl(String urlString, Charset charset)` method
- [x] 1.3 Add `parse(Path path, Charset charset)` method
- [x] 1.4 Add `parseFromFile(String filePath, Charset charset)` convenience method

### Phase 2: Test Coverage Expansion ‚úÖ
- [x] 2.1a Test empty JSON array
- [x] 2.1b Test single row JSON
- [x] 2.1c Test sparse data (null values)
- [x] 2.1d Test invalid JSON (not an array)
- [x] 2.1e Test malformed JSON syntax
- [x] 2.1f Test file not found error
- [x] 2.2a Test null matrix validation
- [x] 2.2b Test empty matrix export
- [x] 2.2c Test matrix with columns but no rows
- [x] 2.2d Test pretty print formatting

### Phase 3: JsonExporter Enhancements ‚úÖ
- [x] 3.1 Add static `toJson(Matrix, boolean)` method
- [x] 3.2 Add static `toJsonFile(Matrix, File, boolean)` method
- [x] 3.3 Add null input validation to constructors
- [x] 3.4 Consider adding @CompileStatic (not implemented - dynamic features needed)

### Phase 4: Documentation Enhancements ‚úÖ
- [x] 4.1 Enhance JsonImporter class-level documentation
- [x] 4.2 Add detailed examples to flatten() method
- [x] 4.3 Add class-level documentation to JsonExporter

---

## Test Coverage Goals ‚úÖ

**Initial**: 8 tests, 100% pass rate
**Target**: 15+ tests, 100% pass rate
**Achieved**: 28 tests, 100% pass rate ‚≠ê

| Test Suite | Initial | Target | Final | New Tests |
|------------|---------|--------|-------|-----------|
| JsonImporterTest | 2 | 8 | 12 | +10 (edge cases, error handling, API methods) |
| JsonExporterTest | 3 | 7 | 13 | +10 (validation, static methods, file export) |
| DuplicateKeyTest | 3 | 3 | 3 | 0 (comprehensive already) |
| **Total** | **8** | **18** | **28** | **+20 tests** (110% over target) |

---

## Dependencies & Compatibility

**No breaking changes** - all enhancements are additive:
- Phase 1: New overloaded methods (no conflicts if naming is careful)
- Phase 2: Test additions only
- Phase 3: New static methods (optional usage)
- Phase 4: Documentation only

**Jackson Compatibility**: No changes to streaming API usage

---

## Estimated Implementation Effort

| Phase | Complexity | Estimated Time | Priority |
|-------|-----------|----------------|----------|
| Phase 1 | Low | 1-2 hours | Medium |
| Phase 2 | Low | 2-3 hours | High |
| Phase 3 | Low | 1 hour | Low |
| Phase 4 | Low | 30 minutes | Low |
| **Total** | **Low** | **4-6 hours** | **High (Phase 2 only)** |

---

## Risks & Considerations

### 1. Method Naming Conflict (Phase 1)

**Risk**: `parse(String)` exists for JSON content, adding `parse(String url)` for URLs causes ambiguity

**Mitigation**: Use `parseFromUrl(String)` and `parseFromFile(String)` for clarity

### 2. Breaking Changes

**Risk**: None - all additions are new methods

**Mitigation**: N/A

### 3. @CompileStatic on JsonExporter (Phase 3.3)

**Risk**: May require refactoring closure-based formatter API

**Mitigation**: Mark as optional; current dynamic approach is acceptable

---

## Success Criteria

**Phase 1**: ‚úÖ API consistency with matrix-csv module achieved
**Phase 2**: ‚úÖ Test count increased from 8 to 18+ with all edge cases covered
**Phase 3**: ‚úÖ Static convenience methods available (optional)
**Phase 4**: ‚úÖ Enhanced documentation with examples

**Overall Success**: Module maintains 100% test pass rate while providing richer API and better coverage

---

## Notes

- **Module Health**: Excellent - no critical issues found
- **Code Quality**: High - clean architecture, good error handling, proper resource management
- **Priority Focus**: Phase 2 (test coverage) is the highest value addition
- **Optional Phases**: Phases 3-4 are nice-to-have enhancements but not critical

This roadmap provides a path from a solid foundation to an even more robust and user-friendly module.
